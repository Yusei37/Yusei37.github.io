{"meta":{"title":"Yusei的博客","subtitle":null,"description":null,"author":"Yusei","url":"https://yusei37.github.io"},"pages":[{"title":"关于我","date":"2018-06-10T05:11:28.000Z","updated":"2018-06-12T14:32:31.289Z","comments":true,"path":"about/index.html","permalink":"https://yusei37.github.io/about/index.html","excerpt":"","text":"我是一名计算机科学与技术专业三年级本科生。有点迷迷糊糊地过了大学三年，回过头来才发现自己是多么得菜，不想让自己今后沦为码农。所以，大学最后一年多的时间，想要重新再拼搏一把，努力改变自己！ 在接下来的半年，我主要精力会复习在考研上，想考浙大，因此也会去刷PAT，并在本博客上更新PAT题解。同时，我也打算重新仔细地阅读《Java编程思想》这本书，加强我Java的基础功力。 写给自己加油吧！未来掌握在自己手上！"},{"title":"知识体系","date":"2018-06-11T02:00:21.000Z","updated":"2018-06-12T14:33:01.546Z","comments":true,"path":"system/index.html","permalink":"https://yusei37.github.io/system/index.html","excerpt":"","text":"目前正在创建中主要会有以下几个方面 Java 算法 Android JavaScript 数据库"}],"posts":[{"title":"PAT1034 Head of a Gang","slug":"PAT1034-Head-of-a-Gang","date":"2018-06-29T14:25:24.000Z","updated":"2018-06-29T15:31:10.889Z","comments":true,"path":"2018/06/29/PAT1034-Head-of-a-Gang/","link":"","permalink":"https://yusei37.github.io/2018/06/29/PAT1034-Head-of-a-Gang/","excerpt":"题目Head of a Gang （一个帮派的头目） 题目链接","text":"题目Head of a Gang （一个帮派的头目） 题目链接 题意给出若干人之间的通话记录，如果两个人之间有通话记录，则认为这两个人有关联，通话时间的长度代表关系的权重。若三个及以上的人之间存在相互关联，则这些人属于一个帮派(gang)，这个帮派的关系权重和等于所有通话时间之和。我们需要根据题目所给定的阈值K，找出所有关系权重和超过K的帮派，输出权重最大的人，也就是这个帮派的头目，以及这个帮派的人数。 解题思路 思路一 图： 如果你对图的算法掌握不错的话，你应该很快就能想到，每个帮派就是一个连通分量。你可以用DFS或者BFS先确定有哪些连通分量，再计算出每个连通分量的总权重，结点个数，权重最大的结点等等。很轻松就解决这个问题了。 思路二 Set/并查集: 这是我的解法。 将每个帮派存入一个集合（Set）。我在每次输入一个通话记录，就去查找这两个人是否存在于现有帮派，如果两个人都存在，只需要改变帮派的总权重和个人的权重即可，如果只有一个存在，则需要将另一个人加入集合，如果两个人都不存在，就为这两个人新建一个集合。 我第一次做这题目是在今年3月初，我当初根据这个思路做，测试点4一直过不了，我也找不出代码的问题。今天再重新检查了代码和回顾了思路，发现了问题所在：当一个通话记录的两个人分别存在于不同的帮派时，处理这条通话记录后，这两个帮派应该是被视为一个帮派（合并成一个帮派）。根据问题修改代码果然也就过了。 这道题目对帮派的处理我用的是C++ STL里的set，也可以用并查集来做。如果用并查集，写法上更加简单，也不会遇到测试点4过不了的问题了。 通过情况 通过代码(C/C++)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;set&gt; using namespace std;int main()&#123; vector&lt;int&gt; w; //所有帮派的权重数组 vector&lt;set&lt;string&gt; &gt; v; //所有帮派集合的数组 set&lt;string&gt; resultName; // 输出结果 帮派头目名称 map&lt;string, int&gt; resultNum; // 输出结果 帮派人数 map迭代以字典序输出结果 map&lt;string, int&gt; m; // 每个人的权重 string a, b; // 读取输入名称的变量 int time; // 读取输入通话时间的变量 int n, k; // 通话次数，阈值 int i, j; // 循环变量 int turn; // 循环变量 scanf(\"%d%d\", &amp;n, &amp;k); for (int turn=0; turn&lt;n; turn++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; time; m[a] += time; m[b] += time; for (i=0; i&lt;v.size(); i++) &#123; set&lt;string&gt;::iterator itAi, itBi, itAj, itBj; itAi = v[i].find(a); itBi = v[i].find(b); if (itAi != v[i].end() || itBi != v[i].end()) &#123; for (j=i+1; j&lt;v.size(); j++) &#123; itAj = v[j].find(a); itBj = v[j].find(b); if (itAj != v[j].end() || itBj != v[j].end()) &#123; break; &#125; &#125; if (j &lt; v.size()) &#123; v[i].insert(v[j].begin(), v[j].end()); v.erase(v.begin() + j); itAi = v[i].find(a); itBi = v[i].find(b); &#125; if (itAi != v[i].end() &amp;&amp; itBi != v[i].end()) &#123; w[i] += time; break; &#125; else if (itAi != v[i].end()) &#123; v[i].insert(b); w[i] += time; break; &#125; else &#123; v[i].insert(a); w[i] += time; break; &#125; &#125;// 未通过测试点4的代码// set&lt;string&gt;::iterator it;// it = v[i].find(a);// if (it == v[i].end()) &#123;// it = v[i].find(b);// if (it == v[i].end()) &#123;// &#125;// else &#123;// v[i].insert(a);// w[i] += time;// break;// &#125;// &#125;// else &#123;// it = v[i].find(b);// if (it == v[i].end()) &#123;// v[i].insert(b);// w[i] += time;// break;// &#125;// else &#123;// w[i] += time;// i=0;// break;// &#125;// &#125; &#125; if (v.size() == 0 || i &gt;= v.size()) &#123; set&lt;string&gt; s; s.insert(a); s.insert(b); v.push_back(s); w.push_back(time); &#125; &#125; // 确定帮派头目和人数 int max = 0; string maxName; for (i=0; i&lt;v.size(); i++) &#123; max = 0; if (v[i].size() &gt;= 3 &amp;&amp; w[i] &gt; k) &#123; set&lt;string&gt;::iterator iter; iter = v[i].begin(); while(iter != v[i].end()) &#123; if (m[(*iter)] &gt; max) &#123; max = m[*iter]; maxName = *iter; &#125; iter++; &#125; resultName.insert(maxName); resultNum[maxName] = v[i].size(); &#125; &#125; // 输入结果 cout &lt;&lt; resultName.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator iter; iter = resultNum.begin(); while(iter != resultNum.end()) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl; iter++; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://yusei37.github.io/categories/PAT/"}],"tags":[{"name":"图","slug":"图","permalink":"https://yusei37.github.io/tags/图/"},{"name":"Set","slug":"Set","permalink":"https://yusei37.github.io/tags/Set/"},{"name":"并查集","slug":"并查集","permalink":"https://yusei37.github.io/tags/并查集/"}]},{"title":"并查集","slug":"并查集","date":"2018-06-24T08:08:06.000Z","updated":"2018-06-26T11:56:20.227Z","comments":true,"path":"2018/06/24/并查集/","link":"","permalink":"https://yusei37.github.io/2018/06/24/并查集/","excerpt":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。","text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。 算法实现（C） 结构定义12const MAXN = 10000;int father[MAXN]; //集合元素数组 初始化123456void init(int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; //把每个子集合的根结点设为自己，也可以是-1 &#125;&#125; 查找 返回元素x所在子集合的根结点 1234567int findFather(int x)&#123; while (x != father[x]) &#123; x = father[x]; &#125; return x;&#125; 合并 如果两个集合根元素不同则合并，如果相同则说明两个集合是同一个集合的子集，不需要合并。 12345678void unionSet(int a, int b)&#123; int fatherA = findFather(a); int fatherB = findFather(b); if (fatherA != fatherB) &#123; father[fatherA] = fatherB; &#125;&#125; 路径压缩上面讲的查找函数是没有经过优化的，当集合路径很长的情况下，显然，查找效率会很低。我们使用并查集的时候，如果只需要得到根结点（子集合名称）即可，与路径无关，那么我们就可以将所有的子元素的父结点直接指向根结点即可。 优化后的查找函数: 123456789101112131415int findFather(int x)&#123; int xCopy = x; while (x != father[x]) &#123; x = father[x]; &#125; //到这里x的值已经变成根结点的值了。 //下面将路径上的所有结点的父结点都改为根结点 while (xCopy != father[xCopy]) &#123; int temp = xCopy; xCopy = father[xCopy]; father[temp] = x; &#125; return x;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://yusei37.github.io/tags/并查集/"},{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"森林","slug":"森林","permalink":"https://yusei37.github.io/tags/森林/"}]},{"title":"平衡二叉树(AVL树)","slug":"平衡二叉-AVL-树","date":"2018-06-23T02:23:52.000Z","updated":"2018-06-26T11:56:16.698Z","comments":true,"path":"2018/06/23/平衡二叉-AVL-树/","link":"","permalink":"https://yusei37.github.io/2018/06/23/平衡二叉-AVL-树/","excerpt":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","text":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 算法实现（C） 结构体定义1234567struct Node&#123; int data; //结点的值 int height; //结点高度 Node* lchild; //结点的左孩子 Node* rchild; //结点的右孩子&#125;; 创建一个新结点123456789Node* newNode(int x)&#123; Node* node = new Node; node-&gt;data = x; node-&gt;height = 1; node-&gt;rchild = NULL; node-&gt;lchild = NULL; return node;&#125; 获取结点的高度123456789int getHeight(Node* root)&#123; if (root == NULL) &#123; return 0; &#125; else &#123; return root-&gt;height; &#125;&#125; 获取结点的平衡因子（左子树高度-右子数高度）1234int getBalanceFactor(Node* root)&#123; return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); &#125; 更新结点高度1234void updateHeight(Node* root)&#123; root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + 1;&#125; 插入AVL树的插入形式同普通二叉树，不同的是AVL树每次插入后，如果平衡因子到达2则需要进行平衡操作 以左旋操作为例 具体步骤如下： 让B的左子树成为A的右子树 让A成为B的左子树 将根结点设为B 右旋操作也是类似的。 LL型，平衡时只需要进行一次右旋操作即可，LR型先平衡左子树，再平衡根树，即先对左子树进行一次左旋,再对根树进行一次右旋。RR型，RL型同理。 具体代码如下: 123456789101112131415161718192021222324252627282930313233void insert(Node* &amp;root, int x)&#123; if (root == NULL) &#123; root = newNode(x); return; &#125; else if (root-&gt;data &gt; x) &#123; insert(root-&gt;lchild, x); updateHeight(root); if (getBalanceFactor(root) == 2) &#123; if (getBalanceFactor(root-&gt;lchild) == 1) &#123; R(root); &#125; else &#123; L(root-&gt;lchild); R(root); &#125; &#125; &#125; else &#123; insert(root-&gt;rchild, x); updateHeight(root); if (getBalanceFactor(root) == -2) &#123; if (getBalanceFactor(root-&gt;rchild) == -1) &#123; L(root); &#125; else &#123; R(root-&gt;rchild); L(root); &#125; &#125; &#125;&#125; 创建一棵AVL树12345678Node* create(vector&lt;int&gt; data)&#123; Node* root = NULL; for (int i = 0; i &lt; data.size(); ++i) &#123; insert(root, data[i]); &#125; return root;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://yusei37.github.io/tags/平衡二叉树/"}]},{"title":"一次SQL Error","slug":"一次SQL-Error","date":"2018-06-10T04:28:11.000Z","updated":"2018-06-10T04:40:04.783Z","comments":true,"path":"2018/06/10/一次SQL-Error/","link":"","permalink":"https://yusei37.github.io/2018/06/10/一次SQL-Error/","excerpt":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1","text":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1 上面的 “…”是其他一些不重要的数据库字段 Debug过程Round 1:&nbsp;&nbsp;&nbsp;&nbsp;既然这个表是插不进数据了，那我索性换张表，重新建了一张名为group2的表，然后再次尝试。&nbsp;&nbsp;&nbsp;&nbsp;果然！结果有了一些小小的变化12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order) values (..., 1)' at line 1 但我还是没发现问题所在，始终不明白错在哪里。 Round 2:&nbsp;&nbsp;&nbsp;&nbsp;遇到问题不会就百度嘛~ &nbsp;&nbsp;&nbsp;&nbsp;百度出来一大堆答案，得到的答案也基本大同小异，都说是数据库字段与SQL保留字段（关键字）冲突。 &nbsp;&nbsp;&nbsp;&nbsp;根据百度的提示一眼就发现order,这个字段是问题所在，改成了其他名称，重新尝试插入数据，结果发现错误仍然不变！&nbsp;&nbsp;&nbsp;&nbsp;又尝试了无数次，多遍检查字段名，我开始有点绝望。 Round 3:蓦然回首，那人却在灯火阑珊处 &nbsp;&nbsp;&nbsp;&nbsp;双手离开键盘，有点无奈。&nbsp;&nbsp;&nbsp;&nbsp;问题应该是字段与SQL保留字段冲突了，但我错在哪里了呢？看了一遍又一遍的错误信息，我终于想起了SQL里还有一个关键字叫做“group”，用于分组。原来是我的表名冲突了！改好表名之后，问题也就解决了，一切都正常了。 总结一下 在这次debug，我用了控制变量法(中学科学实验时，一个十分常用的实验方法，被我用在写代码里，适用性挺强的)，这是我常用的debug方法之一。这个方法虽然很多时候能帮我迅速找到问题代码所在，但遇到这次多处出错的时候，这个办法有点不够用了。 在解决问题之后，我重新回忆了我的debug(写bug)过程,发现我在Round 1时，已经误打误撞的换了表名，但我并没有深究这背后的原因，错过了解决bug的一次机会。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yusei37.github.io/categories/数据库/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://yusei37.github.io/tags/Bug/"}]}]}