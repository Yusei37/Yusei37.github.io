{"meta":{"title":"Yusei的博客","subtitle":null,"description":null,"author":"Yusei","url":"https://yusei37.github.io"},"pages":[{"title":"关于我","date":"2018-06-10T05:11:28.000Z","updated":"2018-06-12T14:32:31.289Z","comments":true,"path":"about/index.html","permalink":"https://yusei37.github.io/about/index.html","excerpt":"","text":"我是一名计算机科学与技术专业三年级本科生。有点迷迷糊糊地过了大学三年，回过头来才发现自己是多么得菜，不想让自己今后沦为码农。所以，大学最后一年多的时间，想要重新再拼搏一把，努力改变自己！ 在接下来的半年，我主要精力会复习在考研上，想考浙大，因此也会去刷PAT，并在本博客上更新PAT题解。同时，我也打算重新仔细地阅读《Java编程思想》这本书，加强我Java的基础功力。 写给自己加油吧！未来掌握在自己手上！"},{"title":"知识体系","date":"2018-06-11T02:00:21.000Z","updated":"2018-06-12T14:33:01.546Z","comments":true,"path":"system/index.html","permalink":"https://yusei37.github.io/system/index.html","excerpt":"","text":"目前正在创建中主要会有以下几个方面 Java 算法 Android JavaScript 数据库"}],"posts":[{"title":"并查集","slug":"并查集","date":"2018-06-24T08:08:06.000Z","updated":"2018-06-26T11:56:20.227Z","comments":true,"path":"2018/06/24/并查集/","link":"","permalink":"https://yusei37.github.io/2018/06/24/并查集/","excerpt":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。","text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。 算法实现（C） 结构定义12const MAXN = 10000;int father[MAXN]; //集合元素数组 初始化123456void init(int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; //把每个子集合的根结点设为自己，也可以是-1 &#125;&#125; 查找 返回元素x所在子集合的根结点 1234567int findFather(int x)&#123; while (x != father[x]) &#123; x = father[x]; &#125; return x;&#125; 合并 如果两个集合根元素不同则合并，如果相同则说明两个集合是同一个集合的子集，不需要合并。 12345678void unionSet(int a, int b)&#123; int fatherA = findFather(a); int fatherB = findFather(b); if (fatherA != fatherB) &#123; father[fatherA] = fatherB; &#125;&#125; 路径压缩上面讲的查找函数是没有经过优化的，当集合路径很长的情况下，显然，查找效率会很低。我们使用并查集的时候，如果只需要得到根结点（子集合名称）即可，与路径无关，那么我们就可以将所有的子元素的父结点直接指向根结点即可。 优化后的查找函数: 123456789101112131415int findFather(int x)&#123; int xCopy = x; while (x != father[x]) &#123; x = father[x]; &#125; //到这里x的值已经变成根结点的值了。 //下面将路径上的所有结点的父结点都改为根结点 while (xCopy != father[xCopy]) &#123; int temp = xCopy; xCopy = father[xCopy]; father[temp] = x; &#125; return x;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"森林","slug":"森林","permalink":"https://yusei37.github.io/tags/森林/"},{"name":"并查集","slug":"并查集","permalink":"https://yusei37.github.io/tags/并查集/"}]},{"title":"平衡二叉树(AVL树)","slug":"平衡二叉-AVL-树","date":"2018-06-23T02:23:52.000Z","updated":"2018-06-26T11:56:16.698Z","comments":true,"path":"2018/06/23/平衡二叉-AVL-树/","link":"","permalink":"https://yusei37.github.io/2018/06/23/平衡二叉-AVL-树/","excerpt":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","text":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 算法实现（C） 结构体定义1234567struct Node&#123; int data; //结点的值 int height; //结点高度 Node* lchild; //结点的左孩子 Node* rchild; //结点的右孩子&#125;; 创建一个新结点123456789Node* newNode(int x)&#123; Node* node = new Node; node-&gt;data = x; node-&gt;height = 1; node-&gt;rchild = NULL; node-&gt;lchild = NULL; return node;&#125; 获取结点的高度123456789int getHeight(Node* root)&#123; if (root == NULL) &#123; return 0; &#125; else &#123; return root-&gt;height; &#125;&#125; 获取结点的平衡因子（左子树高度-右子数高度）1234int getBalanceFactor(Node* root)&#123; return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); &#125; 更新结点高度1234void updateHeight(Node* root)&#123; root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + 1;&#125; 插入AVL树的插入形式同普通二叉树，不同的是AVL树每次插入后，如果平衡因子到达2则需要进行平衡操作 以左旋操作为例 具体步骤如下： 让B的左子树成为A的右子树 让A成为B的左子树 将根结点设为B 右旋操作也是类似的。 LL型，平衡时只需要进行一次右旋操作即可，LR型先平衡左子树，再平衡根树，即先对左子树进行一次左旋,再对根树进行一次右旋。RR型，RL型同理。 具体代码如下: 123456789101112131415161718192021222324252627282930313233void insert(Node* &amp;root, int x)&#123; if (root == NULL) &#123; root = newNode(x); return; &#125; else if (root-&gt;data &gt; x) &#123; insert(root-&gt;lchild, x); updateHeight(root); if (getBalanceFactor(root) == 2) &#123; if (getBalanceFactor(root-&gt;lchild) == 1) &#123; R(root); &#125; else &#123; L(root-&gt;lchild); R(root); &#125; &#125; &#125; else &#123; insert(root-&gt;rchild, x); updateHeight(root); if (getBalanceFactor(root) == -2) &#123; if (getBalanceFactor(root-&gt;rchild) == -1) &#123; L(root); &#125; else &#123; R(root-&gt;rchild); L(root); &#125; &#125; &#125;&#125; 创建一棵AVL树12345678Node* create(vector&lt;int&gt; data)&#123; Node* root = NULL; for (int i = 0; i &lt; data.size(); ++i) &#123; insert(root, data[i]); &#125; return root;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://yusei37.github.io/tags/平衡二叉树/"}]},{"title":"一次SQL Error","slug":"一次SQL-Error","date":"2018-06-10T04:28:11.000Z","updated":"2018-06-10T04:40:04.783Z","comments":true,"path":"2018/06/10/一次SQL-Error/","link":"","permalink":"https://yusei37.github.io/2018/06/10/一次SQL-Error/","excerpt":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1","text":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1 上面的 “…”是其他一些不重要的数据库字段 Debug过程Round 1:&nbsp;&nbsp;&nbsp;&nbsp;既然这个表是插不进数据了，那我索性换张表，重新建了一张名为group2的表，然后再次尝试。&nbsp;&nbsp;&nbsp;&nbsp;果然！结果有了一些小小的变化12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order) values (..., 1)' at line 1 但我还是没发现问题所在，始终不明白错在哪里。 Round 2:&nbsp;&nbsp;&nbsp;&nbsp;遇到问题不会就百度嘛~ &nbsp;&nbsp;&nbsp;&nbsp;百度出来一大堆答案，得到的答案也基本大同小异，都说是数据库字段与SQL保留字段（关键字）冲突。 &nbsp;&nbsp;&nbsp;&nbsp;根据百度的提示一眼就发现order,这个字段是问题所在，改成了其他名称，重新尝试插入数据，结果发现错误仍然不变！&nbsp;&nbsp;&nbsp;&nbsp;又尝试了无数次，多遍检查字段名，我开始有点绝望。 Round 3:蓦然回首，那人却在灯火阑珊处 &nbsp;&nbsp;&nbsp;&nbsp;双手离开键盘，有点无奈。&nbsp;&nbsp;&nbsp;&nbsp;问题应该是字段与SQL保留字段冲突了，但我错在哪里了呢？看了一遍又一遍的错误信息，我终于想起了SQL里还有一个关键字叫做“group”，用于分组。原来是我的表名冲突了！改好表名之后，问题也就解决了，一切都正常了。 总结一下 在这次debug，我用了控制变量法(中学科学实验时，一个十分常用的实验方法，被我用在写代码里，适用性挺强的)，这是我常用的debug方法之一。这个方法虽然很多时候能帮我迅速找到问题代码所在，但遇到这次多处出错的时候，这个办法有点不够用了。 在解决问题之后，我重新回忆了我的debug(写bug)过程,发现我在Round 1时，已经误打误撞的换了表名，但我并没有深究这背后的原因，错过了解决bug的一次机会。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yusei37.github.io/categories/数据库/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://yusei37.github.io/tags/Bug/"}]}]}