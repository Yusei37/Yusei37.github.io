{"meta":{"title":"Yusei的博客","subtitle":null,"description":null,"author":"Yusei","url":"https://yusei37.github.io"},"pages":[{"title":"知识体系","date":"2018-06-11T02:00:21.000Z","updated":"2018-06-12T14:33:01.546Z","comments":true,"path":"system/index.html","permalink":"https://yusei37.github.io/system/index.html","excerpt":"","text":"目前正在创建中主要会有以下几个方面 Java 算法 Android JavaScript 数据库"},{"title":"关于我","date":"2018-06-10T05:11:28.000Z","updated":"2018-06-12T14:32:31.289Z","comments":true,"path":"about/index.html","permalink":"https://yusei37.github.io/about/index.html","excerpt":"","text":"我是一名计算机科学与技术专业三年级本科生。有点迷迷糊糊地过了大学三年，回过头来才发现自己是多么得菜，不想让自己今后沦为码农。所以，大学最后一年多的时间，想要重新再拼搏一把，努力改变自己！ 在接下来的半年，我主要精力会复习在考研上，想考浙大，因此也会去刷PAT，并在本博客上更新PAT题解。同时，我也打算重新仔细地阅读《Java编程思想》这本书，加强我Java的基础功力。 写给自己加油吧！未来掌握在自己手上！"}],"posts":[{"title":"考研碎碎念","slug":"考研碎碎念","date":"2018-07-29T13:48:53.000Z","updated":"2018-07-30T03:15:15.119Z","comments":true,"path":"2018/07/29/考研碎碎念/","link":"","permalink":"https://yusei37.github.io/2018/07/29/考研碎碎念/","excerpt":"暑假已过去一半，我目前考研复习进度一般吧。数学和专业课408基本过了一遍，政治四门课只剩下毛中特还没复习，英语也每天训练着。剩下要做的就是不断强化，刷题，刷真题。","text":"暑假已过去一半，我目前考研复习进度一般吧。数学和专业课408基本过了一遍，政治四门课只剩下毛中特还没复习，英语也每天训练着。剩下要做的就是不断强化，刷题，刷真题。 前两天梦到自己考研考了380分，这个成绩在去年浙大考研也就能压线被录取吧。考研人越来越多，浙大这样的名校报考人数也逐年增加，分数也水涨船高。去年，一名跨考生443分，令人害怕的分数！我没人这样的天赋和实力，但我也会近我的努力去实现自己的目标。 考研目标 科目 分数 数学 130 英语 80 政治 70 408 130 PAT 100 浙大复试上机成绩可以用PAT甲级或顶级成绩代替，我原本计划是18年9月、12月和19年3月考这三次，取一个最高分充当复试成绩。但今年政策突然有点小变化，19考研只能用18年的三次成绩。3月份我没有准备充分，也没去考，损失一次机会！ 复习计划到了强化阶段，复习方向和目标与基础阶段要有所改变，强化阶段不仅仅是刷题，查漏补缺那么简单，更要充分构建知识网络，将所有零散知识尽可能地串联起来。 现阶段计划 科目 计划 数学 1.复习全书 2.刷660和闭关100题 3.归纳考研题目类型 英语 1.每天做阅读，保持手感 2. 每天背单词 3.每天做一年翻译，强化翻译 政治 1.跟视频学政治，做思维导图 2.刷1000题 408 数据结构+网络，组成原理+操作系统，两本两本循环复习 PAT 到9月8日前刷完甲级题库一遍","categories":[{"name":"考研","slug":"考研","permalink":"https://yusei37.github.io/categories/考研/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yusei37.github.io/tags/随笔/"}]},{"title":"Java基础之“goto”","slug":"Java基础之“goto”","date":"2018-07-07T06:24:27.000Z","updated":"2018-07-07T07:18:32.808Z","comments":true,"path":"2018/07/07/Java基础之“goto”/","link":"","permalink":"https://yusei37.github.io/2018/07/07/Java基础之“goto”/","excerpt":"gotogoto起源于汇编语言的程序控制：“若条件A成立，则跳转到这里；否则跳到哪里”。但在我们学习结构化程序设计时，一般都部长我们使用goto语句。过多的goto会造成程序流程的混乱，同时使理解和调试程序都变得困难。","text":"gotogoto起源于汇编语言的程序控制：“若条件A成立，则跳转到这里；否则跳到哪里”。但在我们学习结构化程序设计时，一般都部长我们使用goto语句。过多的goto会造成程序流程的混乱，同时使理解和调试程序都变得困难。 尽管goto是Java中的一个保留字，但在语言中并没未被使用。而Java中结合break、continue与标签(label)可以实现与goto一样的跳转。 标签标签是后面跟冒号的标识符，如下所示:1label1: break和continue单独使用只会中断当前循环，但如果和标签一起使用，它们不仅会中断循环，而且会直接跳转直标签处。 使用方法下面是《Thinking in Java》上的一个例子:1234567891011121314151617181920212223242526272829303132333435363738public class LabledFor &#123; public static void main(String[] args) &#123; int i = 0; outer: //外层标签 for (;true;) &#123; inner: //内层标签 for (; i &lt; 10; i++) &#123; System.out.println(\"i = \" + i); if (i == 2) &#123; System.out.println(\"continue\"); continue; &#125; if (i == 3) &#123; System.out.println(\"break\"); i++; break; &#125; if (i == 7) &#123; System.out.println(\"continue outer\"); i++; continue outer; &#125; if (i == 8) &#123; System.out.println(\"break outer\"); break outer; &#125; for (int k = 0; k &lt; 5; k++) &#123; if (k == 3) &#123; System.out.println(\"continue inner\"); continue inner; &#125; &#125; &#125; &#125; &#125;&#125; 输出结果: 一些想法与感受似乎之前学习Java没听人提起过label，我一直以为break和continue后面不能跟任何代码。这次重新学习,不仅填补了我的知识漏洞，也让我对Java程序流程控制有了新的理解。 虽然“goto”的名声不好，但主要原因是因为滥用，合理运用“goto”，或许能帮助你更有效地实现控制流程。","categories":[{"name":"Java","slug":"Java","permalink":"https://yusei37.github.io/categories/Java/"}],"tags":[{"name":"Thinking in Java","slug":"Thinking-in-Java","permalink":"https://yusei37.github.io/tags/Thinking-in-Java/"},{"name":"控制执行流程","slug":"控制执行流程","permalink":"https://yusei37.github.io/tags/控制执行流程/"}]},{"title":"PAT1034 Head of a Gang","slug":"PAT1034-Head-of-a-Gang","date":"2018-06-29T14:25:24.000Z","updated":"2018-06-29T15:31:10.889Z","comments":true,"path":"2018/06/29/PAT1034-Head-of-a-Gang/","link":"","permalink":"https://yusei37.github.io/2018/06/29/PAT1034-Head-of-a-Gang/","excerpt":"题目Head of a Gang （一个帮派的头目） 题目链接","text":"题目Head of a Gang （一个帮派的头目） 题目链接 题意给出若干人之间的通话记录，如果两个人之间有通话记录，则认为这两个人有关联，通话时间的长度代表关系的权重。若三个及以上的人之间存在相互关联，则这些人属于一个帮派(gang)，这个帮派的关系权重和等于所有通话时间之和。我们需要根据题目所给定的阈值K，找出所有关系权重和超过K的帮派，输出权重最大的人，也就是这个帮派的头目，以及这个帮派的人数。 解题思路 思路一 图： 如果你对图的算法掌握不错的话，你应该很快就能想到，每个帮派就是一个连通分量。你可以用DFS或者BFS先确定有哪些连通分量，再计算出每个连通分量的总权重，结点个数，权重最大的结点等等。很轻松就解决这个问题了。 思路二 Set/并查集: 这是我的解法。 将每个帮派存入一个集合（Set）。我在每次输入一个通话记录，就去查找这两个人是否存在于现有帮派，如果两个人都存在，只需要改变帮派的总权重和个人的权重即可，如果只有一个存在，则需要将另一个人加入集合，如果两个人都不存在，就为这两个人新建一个集合。 我第一次做这题目是在今年3月初，我当初根据这个思路做，测试点4一直过不了，我也找不出代码的问题。今天再重新检查了代码和回顾了思路，发现了问题所在：当一个通话记录的两个人分别存在于不同的帮派时，处理这条通话记录后，这两个帮派应该是被视为一个帮派（合并成一个帮派）。根据问题修改代码果然也就过了。 这道题目对帮派的处理我用的是C++ STL里的set，也可以用并查集来做。如果用并查集，写法上更加简单，也不会遇到测试点4过不了的问题了。 通过情况 通过代码(C/C++)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;set&gt; using namespace std;int main()&#123; vector&lt;int&gt; w; //所有帮派的权重数组 vector&lt;set&lt;string&gt; &gt; v; //所有帮派集合的数组 set&lt;string&gt; resultName; // 输出结果 帮派头目名称 map&lt;string, int&gt; resultNum; // 输出结果 帮派人数 map迭代以字典序输出结果 map&lt;string, int&gt; m; // 每个人的权重 string a, b; // 读取输入名称的变量 int time; // 读取输入通话时间的变量 int n, k; // 通话次数，阈值 int i, j; // 循环变量 int turn; // 循环变量 scanf(\"%d%d\", &amp;n, &amp;k); for (int turn=0; turn&lt;n; turn++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; time; m[a] += time; m[b] += time; for (i=0; i&lt;v.size(); i++) &#123; set&lt;string&gt;::iterator itAi, itBi, itAj, itBj; itAi = v[i].find(a); itBi = v[i].find(b); if (itAi != v[i].end() || itBi != v[i].end()) &#123; for (j=i+1; j&lt;v.size(); j++) &#123; itAj = v[j].find(a); itBj = v[j].find(b); if (itAj != v[j].end() || itBj != v[j].end()) &#123; break; &#125; &#125; if (j &lt; v.size()) &#123; v[i].insert(v[j].begin(), v[j].end()); v.erase(v.begin() + j); itAi = v[i].find(a); itBi = v[i].find(b); &#125; if (itAi != v[i].end() &amp;&amp; itBi != v[i].end()) &#123; w[i] += time; break; &#125; else if (itAi != v[i].end()) &#123; v[i].insert(b); w[i] += time; break; &#125; else &#123; v[i].insert(a); w[i] += time; break; &#125; &#125;// 未通过测试点4的代码// set&lt;string&gt;::iterator it;// it = v[i].find(a);// if (it == v[i].end()) &#123;// it = v[i].find(b);// if (it == v[i].end()) &#123;// &#125;// else &#123;// v[i].insert(a);// w[i] += time;// break;// &#125;// &#125;// else &#123;// it = v[i].find(b);// if (it == v[i].end()) &#123;// v[i].insert(b);// w[i] += time;// break;// &#125;// else &#123;// w[i] += time;// i=0;// break;// &#125;// &#125; &#125; if (v.size() == 0 || i &gt;= v.size()) &#123; set&lt;string&gt; s; s.insert(a); s.insert(b); v.push_back(s); w.push_back(time); &#125; &#125; // 确定帮派头目和人数 int max = 0; string maxName; for (i=0; i&lt;v.size(); i++) &#123; max = 0; if (v[i].size() &gt;= 3 &amp;&amp; w[i] &gt; k) &#123; set&lt;string&gt;::iterator iter; iter = v[i].begin(); while(iter != v[i].end()) &#123; if (m[(*iter)] &gt; max) &#123; max = m[*iter]; maxName = *iter; &#125; iter++; &#125; resultName.insert(maxName); resultNum[maxName] = v[i].size(); &#125; &#125; // 输入结果 cout &lt;&lt; resultName.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator iter; iter = resultNum.begin(); while(iter != resultNum.end()) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl; iter++; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://yusei37.github.io/categories/PAT/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://yusei37.github.io/tags/并查集/"},{"name":"图","slug":"图","permalink":"https://yusei37.github.io/tags/图/"},{"name":"Set","slug":"Set","permalink":"https://yusei37.github.io/tags/Set/"}]},{"title":"并查集","slug":"并查集","date":"2018-06-24T08:08:06.000Z","updated":"2018-06-26T11:56:20.227Z","comments":true,"path":"2018/06/24/并查集/","link":"","permalink":"https://yusei37.github.io/2018/06/24/并查集/","excerpt":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。","text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。它的名字中“并”、“查”、“集”分别取字union、find、set这3个单词。它支持以下三种操作： 初始化：将集合中的每一个元素都初始化为只有一个单元素的子集合。 查找：查找集合中某个元素所在的子集合，并返回该子集合的名称。 合并：将两个集合合并。 算法实现（C） 结构定义12const MAXN = 10000;int father[MAXN]; //集合元素数组 初始化123456void init(int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; //把每个子集合的根结点设为自己，也可以是-1 &#125;&#125; 查找 返回元素x所在子集合的根结点 1234567int findFather(int x)&#123; while (x != father[x]) &#123; x = father[x]; &#125; return x;&#125; 合并 如果两个集合根元素不同则合并，如果相同则说明两个集合是同一个集合的子集，不需要合并。 12345678void unionSet(int a, int b)&#123; int fatherA = findFather(a); int fatherB = findFather(b); if (fatherA != fatherB) &#123; father[fatherA] = fatherB; &#125;&#125; 路径压缩上面讲的查找函数是没有经过优化的，当集合路径很长的情况下，显然，查找效率会很低。我们使用并查集的时候，如果只需要得到根结点（子集合名称）即可，与路径无关，那么我们就可以将所有的子元素的父结点直接指向根结点即可。 优化后的查找函数: 123456789101112131415int findFather(int x)&#123; int xCopy = x; while (x != father[x]) &#123; x = father[x]; &#125; //到这里x的值已经变成根结点的值了。 //下面将路径上的所有结点的父结点都改为根结点 while (xCopy != father[xCopy]) &#123; int temp = xCopy; xCopy = father[xCopy]; father[temp] = x; &#125; return x;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"森林","slug":"森林","permalink":"https://yusei37.github.io/tags/森林/"},{"name":"并查集","slug":"并查集","permalink":"https://yusei37.github.io/tags/并查集/"}]},{"title":"平衡二叉树(AVL树)","slug":"平衡二叉-AVL-树","date":"2018-06-23T02:23:52.000Z","updated":"2018-06-26T11:56:16.698Z","comments":true,"path":"2018/06/23/平衡二叉-AVL-树/","link":"","permalink":"https://yusei37.github.io/2018/06/23/平衡二叉-AVL-树/","excerpt":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","text":"定义平衡二叉树，又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 算法实现（C） 结构体定义1234567struct Node&#123; int data; //结点的值 int height; //结点高度 Node* lchild; //结点的左孩子 Node* rchild; //结点的右孩子&#125;; 创建一个新结点123456789Node* newNode(int x)&#123; Node* node = new Node; node-&gt;data = x; node-&gt;height = 1; node-&gt;rchild = NULL; node-&gt;lchild = NULL; return node;&#125; 获取结点的高度123456789int getHeight(Node* root)&#123; if (root == NULL) &#123; return 0; &#125; else &#123; return root-&gt;height; &#125;&#125; 获取结点的平衡因子（左子树高度-右子数高度）1234int getBalanceFactor(Node* root)&#123; return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); &#125; 更新结点高度1234void updateHeight(Node* root)&#123; root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + 1;&#125; 插入AVL树的插入形式同普通二叉树，不同的是AVL树每次插入后，如果平衡因子到达2则需要进行平衡操作 以左旋操作为例 具体步骤如下： 让B的左子树成为A的右子树 让A成为B的左子树 将根结点设为B 右旋操作也是类似的。 LL型，平衡时只需要进行一次右旋操作即可，LR型先平衡左子树，再平衡根树，即先对左子树进行一次左旋,再对根树进行一次右旋。RR型，RL型同理。 具体代码如下: 123456789101112131415161718192021222324252627282930313233void insert(Node* &amp;root, int x)&#123; if (root == NULL) &#123; root = newNode(x); return; &#125; else if (root-&gt;data &gt; x) &#123; insert(root-&gt;lchild, x); updateHeight(root); if (getBalanceFactor(root) == 2) &#123; if (getBalanceFactor(root-&gt;lchild) == 1) &#123; R(root); &#125; else &#123; L(root-&gt;lchild); R(root); &#125; &#125; &#125; else &#123; insert(root-&gt;rchild, x); updateHeight(root); if (getBalanceFactor(root) == -2) &#123; if (getBalanceFactor(root-&gt;rchild) == -1) &#123; L(root); &#125; else &#123; R(root-&gt;rchild); L(root); &#125; &#125; &#125;&#125; 创建一棵AVL树12345678Node* create(vector&lt;int&gt; data)&#123; Node* root = NULL; for (int i = 0; i &lt; data.size(); ++i) &#123; insert(root, data[i]); &#125; return root;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yusei37.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://yusei37.github.io/tags/树/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://yusei37.github.io/tags/平衡二叉树/"}]},{"title":"一次SQL Error","slug":"一次SQL-Error","date":"2018-06-10T04:28:11.000Z","updated":"2018-06-10T04:40:04.783Z","comments":true,"path":"2018/06/10/一次SQL-Error/","link":"","permalink":"https://yusei37.github.io/2018/06/10/一次SQL-Error/","excerpt":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1","text":"遇到问题：SQL Error: 1064, SQLState: 42000今天在使用JavaEE连接MySQL数据库插入数据时，遇到了如下问题：12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'group(..., order) values (..., 1)' at line 1 上面的 “…”是其他一些不重要的数据库字段 Debug过程Round 1:&nbsp;&nbsp;&nbsp;&nbsp;既然这个表是插不进数据了，那我索性换张表，重新建了一张名为group2的表，然后再次尝试。&nbsp;&nbsp;&nbsp;&nbsp;果然！结果有了一些小小的变化12WARN SQL Error: 1064, SQLState: 42000ERROR You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order) values (..., 1)' at line 1 但我还是没发现问题所在，始终不明白错在哪里。 Round 2:&nbsp;&nbsp;&nbsp;&nbsp;遇到问题不会就百度嘛~ &nbsp;&nbsp;&nbsp;&nbsp;百度出来一大堆答案，得到的答案也基本大同小异，都说是数据库字段与SQL保留字段（关键字）冲突。 &nbsp;&nbsp;&nbsp;&nbsp;根据百度的提示一眼就发现order,这个字段是问题所在，改成了其他名称，重新尝试插入数据，结果发现错误仍然不变！&nbsp;&nbsp;&nbsp;&nbsp;又尝试了无数次，多遍检查字段名，我开始有点绝望。 Round 3:蓦然回首，那人却在灯火阑珊处 &nbsp;&nbsp;&nbsp;&nbsp;双手离开键盘，有点无奈。&nbsp;&nbsp;&nbsp;&nbsp;问题应该是字段与SQL保留字段冲突了，但我错在哪里了呢？看了一遍又一遍的错误信息，我终于想起了SQL里还有一个关键字叫做“group”，用于分组。原来是我的表名冲突了！改好表名之后，问题也就解决了，一切都正常了。 总结一下 在这次debug，我用了控制变量法(中学科学实验时，一个十分常用的实验方法，被我用在写代码里，适用性挺强的)，这是我常用的debug方法之一。这个方法虽然很多时候能帮我迅速找到问题代码所在，但遇到这次多处出错的时候，这个办法有点不够用了。 在解决问题之后，我重新回忆了我的debug(写bug)过程,发现我在Round 1时，已经误打误撞的换了表名，但我并没有深究这背后的原因，错过了解决bug的一次机会。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yusei37.github.io/categories/数据库/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://yusei37.github.io/tags/Bug/"}]}]}